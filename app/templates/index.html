{% extends "base.html" %}

{% block title %}Create Event - EventHub{% endblock %}

{% block content %}
<div class="flex flex-1 min-h-0">
    <!-- Left: Chat Interface - Fixed layout with sticky input -->
    <div class="w-1/2 flex flex-col border-r border-slate-700 min-h-0">
        <!-- Header - Fixed at top -->
        <div class="flex-shrink-0 p-4 border-b border-slate-700 bg-slate-800">
            <h1 class="text-xl font-bold text-blue-400">Event Architect AI</h1>
            <p class="text-sm text-slate-400">Powered by Ollama & LangGraph</p>
        </div>

        <!-- Chat History Container - Scrollable middle section -->
        <div id="chat-history" class="flex-1 h-0 overflow-y-auto p-4 space-y-4 min-h-0 custom-scrollbar">
            <!-- Initial Greeting -->
            <div class="flex flex-col space-y-1 items-start">
                <div class="bg-slate-700 text-slate-100 p-3 rounded-lg rounded-tl-none max-w-[80%]">
                    Hello! I'm your event planning assistant. I can help you build complex event structures. What kind of event are you planning today?
                </div>
            </div>
            
            <!-- Render existing chat history from session (persists across page refresh) -->
            {% for msg in history %}
                {% if msg[0] == "user" %}
                    <div class="flex flex-col space-y-1 items-end">
                        <div class="bg-blue-600 text-white p-3 rounded-lg rounded-tr-none max-w-[80%]">
                            {{ msg[1] | e | replace('\n', '<br>') | safe }}
                        </div>
                    </div>
                {% elif msg[0] == "ai" %}
                    <div class="flex flex-col space-y-1 items-start">
                        <div class="bg-slate-700 text-slate-100 p-3 rounded-lg rounded-tl-none max-w-[80%]">
                            {{ msg[1] }}
                        </div>
                    </div>
                {% endif %}
            {% endfor %}
        </div>

        <!-- Input Area - Fixed at bottom -->
        <div class="flex-shrink-0 p-4 bg-slate-800 border-t border-slate-700">
            <form id="chat-form" hx-post="/chat" hx-target="#chat-history" hx-swap="beforeend" 
                  hx-indicator="#processing-indicator" class="flex gap-2">
                <div class="flex-1 relative">
                    <textarea name="user_message" id="user-message-input"
                       class="w-full bg-slate-900 border border-slate-600 rounded-lg px-4 py-2 focus:outline-none focus:border-blue-500 transition resize-none"
                       placeholder="Describe your event... (Shift+Enter for new line)" required autocomplete="off"
                       rows="1" style="min-height: 42px; max-height: 200px;"></textarea>
                    <!-- Processing Indicator -->
                    <div id="processing-indicator" class="htmx-indicator absolute right-3 top-3">
                        <div class="flex items-center gap-2 text-blue-400">
                            <svg class="animate-spin h-5 w-5" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                            </svg>
                            <span class="text-sm">Processing...</span>
                        </div>
                    </div>
                </div>
                <!-- Microphone Button (hidden by default, shown when Whisper is available) -->
                <button type="button" id="mic-button" 
                        class="hidden bg-slate-700 hover:bg-rose-600 px-4 py-2 rounded-lg font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed self-end group"
                        title="Hold to record voice input">
                    <svg id="mic-icon" class="w-5 h-5 text-slate-400 group-hover:text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"></path>
                    </svg>
                    <svg id="mic-recording-icon" class="hidden w-5 h-5 text-rose-400 animate-pulse" fill="currentColor" viewBox="0 0 24 24">
                        <circle cx="12" cy="12" r="6"></circle>
                    </svg>
                </button>
                <button type="submit" id="send-button" class="bg-blue-600 hover:bg-blue-500 px-6 py-2 rounded-lg font-semibold transition disabled:opacity-50 disabled:cursor-not-allowed self-end">
                    Send
                </button>
            </form>
            <!-- Voice recording status -->
            <div id="voice-status" class="hidden mt-2 text-sm text-rose-400 flex items-center gap-2">
                <span class="flex h-2 w-2">
                    <span class="animate-ping absolute inline-flex h-2 w-2 rounded-full bg-rose-400 opacity-75"></span>
                    <span class="relative inline-flex rounded-full h-2 w-2 bg-rose-500"></span>
                </span>
                <span id="voice-status-text">Recording...</span>
            </div>
        </div>
    </div>

    <!-- Right: Event Preview (State Visualization) - Independent scroll -->
    <div class="w-1/2 bg-slate-950 flex flex-col min-h-0">
        <!-- Header - Fixed at top -->
        <div class="flex-shrink-0 p-6 pb-0">
            <div class="flex justify-between items-center mb-6">
                <h2 class="text-xl font-bold">Event Draft</h2>
                <span class="text-xs uppercase tracking-wider text-slate-500 bg-slate-900 px-2 py-1 rounded">Live Preview</span>
            </div>
        </div>

        <!-- Scrollable Event Preview Content -->
        <div id="event-preview-container" class="flex-1 h-0 overflow-y-auto px-6 min-h-0 custom-scrollbar">
            {% include "components/event_preview_content.html" %}
        </div>
        
        <!-- Save Event Button - Fixed at bottom -->
        <div class="flex-shrink-0 p-6 pt-4 border-t border-slate-700 bg-slate-950">
            {% if error %}
            <div class="bg-red-900 border border-red-700 text-red-200 px-4 py-3 rounded mb-4">
                {{ error }}
            </div>
            {% endif %}
            
            {# Calculate initial validation status #}
            {% set has_title = draft.title is defined and draft.title %}
            {% set has_is_online = draft.is_online is not none %}
            {% set has_start_time = draft.start_time is defined and draft.start_time %}
            {% set needs_location = draft.is_online == false %}
            {% set has_location = draft.location_address is defined and draft.location_address %}
            {% set location_valid = not needs_location or has_location %}
            {% set can_publish = has_title and has_is_online and has_start_time and location_valid %}
            
            <div id="save-event-button-container" class="flex justify-between items-center gap-4">
                <button type="button" 
                        id="clear-draft-button"
                        class="bg-slate-700 hover:bg-slate-600 text-white px-6 py-3 rounded-lg font-semibold transition">
                    Clear Draft
                </button>
                <form method="POST" action="/save-event" class="flex justify-end">
                    <button type="submit" 
                            {% if not can_publish %}disabled{% endif %}
                            class="{% if can_publish %}bg-emerald-600 hover:bg-emerald-500{% else %}bg-slate-700 cursor-not-allowed{% endif %} text-white px-6 py-3 rounded-lg font-semibold transition disabled:opacity-50">
                        {% if can_publish %}
                            Save Event
                        {% else %}
                            Complete Required Fields
                        {% endif %}
                    </button>
                </form>
            </div>
        </div>
    </div>
</div>

<!-- Clear Draft Modal -->
<div id="clear-draft-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
    <div class="bg-slate-800 rounded-lg p-6 max-w-md w-full mx-4 border border-slate-700">
        <h3 class="text-xl font-bold text-white mb-4">Clear Draft</h3>
        <p class="text-slate-300 mb-6">What would you like to do with your current draft?</p>
        
        <div class="flex flex-col gap-3">
            <button type="button" 
                    id="delete-draft-button"
                    class="w-full bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg font-semibold transition">
                Delete Permanently
            </button>
            
            <button type="button" 
                    id="save-draft-button"
                    class="w-full bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg font-semibold transition">
                Save Draft (Keep in Session)
            </button>
            
            <button type="button" 
                    id="cancel-clear-button"
                    class="w-full bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg font-semibold transition">
                Cancel
            </button>
        </div>
        
        <!-- Warning message for delete -->
        <div id="delete-warning" class="hidden mt-4 p-3 bg-red-900 border border-red-700 rounded text-red-200 text-sm">
            <p class="font-semibold mb-1">⚠️ Warning: This action cannot be undone!</p>
            <p>All draft data and chat history will be permanently deleted.</p>
        </div>
    </div>
</div>

<!-- Delete Confirmation Modal -->
<div id="delete-confirm-modal" class="hidden fixed inset-0 bg-black bg-opacity-50 z-50 flex items-center justify-center">
    <div class="bg-slate-800 rounded-lg p-6 max-w-md w-full mx-4 border border-red-700">
        <h3 class="text-xl font-bold text-red-400 mb-4">⚠️ Confirm Permanent Deletion</h3>
        <p class="text-slate-300 mb-2">Are you sure you want to permanently delete your draft?</p>
        <div class="bg-red-900 border border-red-700 rounded p-3 mb-6 text-red-200 text-sm">
            <p class="font-semibold mb-1">This action cannot be undone!</p>
            <p>All draft data and chat history will be permanently deleted.</p>
        </div>
        
        <div class="flex gap-3">
            <button type="button" 
                    id="cancel-delete-button"
                    class="flex-1 bg-slate-700 hover:bg-slate-600 text-white px-4 py-2 rounded-lg font-semibold transition">
                Cancel
            </button>
            <button type="button" 
                    id="confirm-delete-button"
                    class="flex-1 bg-red-600 hover:bg-red-500 text-white px-4 py-2 rounded-lg font-semibold transition">
                Yes, Delete Permanently
            </button>
        </div>
    </div>
</div>

<script>
    const chatForm = document.getElementById('chat-form');
    const userMessageInput = document.getElementById('user-message-input');
    const sendButton = document.getElementById('send-button');
    const micButton = document.getElementById('mic-button');
    const micIcon = document.getElementById('mic-icon');
    const micRecordingIcon = document.getElementById('mic-recording-icon');
    const voiceStatus = document.getElementById('voice-status');
    const voiceStatusText = document.getElementById('voice-status-text');
    
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    let whisperAvailable = false;
    
    // Helper function to escape HTML
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Helper function to immediately show user message
    function showUserMessage() {
        const messageText = userMessageInput.value.trim();
        if (!messageText) return;
        
        // Immediately show user message in chat
        const chatHistory = document.getElementById("chat-history");
        const userMessageDiv = document.createElement('div');
        userMessageDiv.className = 'flex flex-col space-y-1 items-end';
        // Escape HTML and convert newlines to <br>
        const escapedText = escapeHtml(messageText).replace(/\n/g, '<br>');
        userMessageDiv.innerHTML = `
            <div class="bg-blue-600 text-white p-3 rounded-lg rounded-tr-none max-w-[80%]">
                ${escapedText}
            </div>
        `;
        chatHistory.appendChild(userMessageDiv);
        
        // Scroll to bottom
        chatHistory.scrollTop = chatHistory.scrollHeight;
    }
    
    // Auto-resize textarea
    userMessageInput.addEventListener('input', function() {
        this.style.height = 'auto';
        this.style.height = Math.min(this.scrollHeight, 200) + 'px';
    });
    
    // Handle Enter vs Shift+Enter
    userMessageInput.addEventListener('keydown', function(e) {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            if (!sendButton.disabled && this.value.trim()) {
                chatForm.requestSubmit();
            }
        }
        // Shift+Enter allows default behavior (new line)
    });
    
    // Handle form submit (button click or Enter key) - show user message here to avoid duplicates
    chatForm.addEventListener('submit', function(e) {
        if (userMessageInput.value.trim() && !sendButton.disabled) {
            showUserMessage();
        }
    });
    
    // Disable input and button when processing starts, and clear input after HTMX reads it
    document.body.addEventListener('htmx:beforeRequest', function(evt) {
        userMessageInput.disabled = true;
        sendButton.disabled = true;
        // Clear input now that HTMX has read the form data
        userMessageInput.value = '';
        userMessageInput.style.height = 'auto';
    });
    
    // Re-enable input and button when request completes (success or error)
    document.body.addEventListener('htmx:afterRequest', function(evt) {
        userMessageInput.disabled = false;
        sendButton.disabled = false;
        userMessageInput.focus();
    });
    
    // Handle successful response
    document.body.addEventListener('htmx:afterSwap', function(evt) {
        // Auto scroll chat to bottom
        const chatContainer = document.getElementById("chat-history");
        chatContainer.scrollTop = chatContainer.scrollHeight;
    });
    
    // ========================================================================
    // VOICE INPUT FUNCTIONALITY
    // ========================================================================
    
    // Check if Whisper is available
    async function checkWhisperAvailability() {
        try {
            const response = await fetch('/whisper/available');
            const data = await response.json();
            whisperAvailable = data.available;
            
            if (whisperAvailable) {
                micButton.classList.remove('hidden');
            }
        } catch (e) {
            console.log('Whisper not available:', e);
        }
    }
    
    // Convert WebM to WAV
    async function convertToWav(webmBlob) {
        const arrayBuffer = await webmBlob.arrayBuffer();
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        try {
            const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
            const targetSampleRate = 16000;
            const offlineContext = new OfflineAudioContext(1, audioBuffer.duration * targetSampleRate, targetSampleRate);
            
            const source = offlineContext.createBufferSource();
            source.buffer = audioBuffer;
            source.connect(offlineContext.destination);
            source.start(0);
            
            const renderedBuffer = await offlineContext.startRendering();
            const wavData = encodeWav(renderedBuffer);
            
            return new Blob([wavData], { type: 'audio/wav' });
        } finally {
            audioContext.close();
        }
    }
    
    function encodeWav(audioBuffer) {
        const numChannels = audioBuffer.numberOfChannels;
        const sampleRate = audioBuffer.sampleRate;
        const format = 1;
        const bitsPerSample = 16;
        
        const samples = audioBuffer.getChannelData(0);
        const buffer = new ArrayBuffer(44 + samples.length * 2);
        const view = new DataView(buffer);
        
        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }
        
        writeString(view, 0, 'RIFF');
        view.setUint32(4, 36 + samples.length * 2, true);
        writeString(view, 8, 'WAVE');
        writeString(view, 12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, format, true);
        view.setUint16(22, numChannels, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * numChannels * bitsPerSample / 8, true);
        view.setUint16(32, numChannels * bitsPerSample / 8, true);
        view.setUint16(34, bitsPerSample, true);
        writeString(view, 36, 'data');
        view.setUint32(40, samples.length * 2, true);
        
        let offset = 44;
        for (let i = 0; i < samples.length; i++, offset += 2) {
            const s = Math.max(-1, Math.min(1, samples[i]));
            view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
        
        return buffer;
    }
    
    async function startRecording() {
        try {
            const deviceId = localStorage.getItem('whisper_mic_device_id');
            const constraints = {
                audio: deviceId ? { deviceId: { exact: deviceId } } : true
            };
            
            const stream = await navigator.mediaDevices.getUserMedia(constraints);
            
            mediaRecorder = new MediaRecorder(stream, {
                mimeType: 'audio/webm;codecs=opus'
            });
            
            audioChunks = [];
            
            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    audioChunks.push(e.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                stream.getTracks().forEach(track => track.stop());
                await processVoiceRecording();
            };
            
            mediaRecorder.start(100);
            isRecording = true;
            
            // Update UI
            micIcon.classList.add('hidden');
            micRecordingIcon.classList.remove('hidden');
            micButton.classList.remove('bg-slate-700', 'hover:bg-rose-600');
            micButton.classList.add('bg-rose-600');
            voiceStatus.classList.remove('hidden');
            voiceStatusText.textContent = 'Recording... (click to stop)';
            
        } catch (e) {
            console.error('Error starting recording:', e);
            voiceStatus.classList.remove('hidden');
            voiceStatusText.textContent = 'Microphone access denied. Check Voice Config.';
            voiceStatusText.classList.add('text-amber-400');
            voiceStatusText.classList.remove('text-rose-400');
            setTimeout(() => {
                voiceStatus.classList.add('hidden');
                voiceStatusText.classList.remove('text-amber-400');
                voiceStatusText.classList.add('text-rose-400');
            }, 3000);
        }
    }
    
    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state === 'recording') {
            mediaRecorder.stop();
            isRecording = false;
            
            // Reset button UI
            micIcon.classList.remove('hidden');
            micRecordingIcon.classList.add('hidden');
            micButton.classList.add('bg-slate-700', 'hover:bg-rose-600');
            micButton.classList.remove('bg-rose-600');
        }
    }
    
    async function processVoiceRecording() {
        if (audioChunks.length === 0) {
            voiceStatus.classList.add('hidden');
            return;
        }
        
        voiceStatusText.textContent = 'Transcribing...';
        micButton.disabled = true;
        
        try {
            const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
            const wavBlob = await convertToWav(audioBlob);
            
            const formData = new FormData();
            formData.append('audio', wavBlob, 'recording.wav');
            
            const response = await fetch('/whisper/transcribe', {
                method: 'POST',
                body: formData
            });
            
            const result = await response.json();
            
            if (result.success && result.text) {
                // Put transcribed text in input
                userMessageInput.value = result.text;
                userMessageInput.dispatchEvent(new Event('input'));
                userMessageInput.focus();
                voiceStatusText.textContent = 'Transcribed! Press Enter to send.';
            } else {
                voiceStatusText.textContent = result.error || 'No speech detected';
                voiceStatusText.classList.add('text-amber-400');
                voiceStatusText.classList.remove('text-rose-400');
            }
            
        } catch (e) {
            console.error('Transcription error:', e);
            voiceStatusText.textContent = 'Transcription failed';
            voiceStatusText.classList.add('text-amber-400');
            voiceStatusText.classList.remove('text-rose-400');
        } finally {
            micButton.disabled = false;
            
            // Hide status after delay
            setTimeout(() => {
                voiceStatus.classList.add('hidden');
                voiceStatusText.classList.remove('text-amber-400');
                voiceStatusText.classList.add('text-rose-400');
            }, 3000);
        }
    }
    
    // Mic button click handler
    micButton?.addEventListener('click', () => {
        if (isRecording) {
            stopRecording();
        } else {
            startRecording();
        }
    });
    
    // Check whisper on page load
    checkWhisperAvailability();
    
    // ========================================================================
    // CLEAR DRAFT FUNCTIONALITY
    // ========================================================================
    
    const clearDraftButton = document.getElementById('clear-draft-button');
    const clearDraftModal = document.getElementById('clear-draft-modal');
    const deleteConfirmModal = document.getElementById('delete-confirm-modal');
    const cancelClearButton = document.getElementById('cancel-clear-button');
    const saveDraftButton = document.getElementById('save-draft-button');
    const deleteDraftButton = document.getElementById('delete-draft-button');
    const confirmDeleteButton = document.getElementById('confirm-delete-button');
    const cancelDeleteButton = document.getElementById('cancel-delete-button');
    const deleteWarning = document.getElementById('delete-warning');
    
    // Show modal when Clear Draft button is clicked
    clearDraftButton?.addEventListener('click', () => {
        clearDraftModal.classList.remove('hidden');
        deleteWarning.classList.add('hidden');
    });
    
    // Hide modal when Cancel is clicked
    cancelClearButton?.addEventListener('click', () => {
        clearDraftModal.classList.add('hidden');
        deleteWarning.classList.add('hidden');
    });
    
    // Hide modal when clicking outside
    clearDraftModal?.addEventListener('click', (e) => {
        if (e.target === clearDraftModal) {
            clearDraftModal.classList.add('hidden');
            deleteWarning.classList.add('hidden');
        }
    });
    
    // Show warning when Delete Permanently button is hovered or focused
    deleteDraftButton?.addEventListener('mouseenter', () => {
        deleteWarning.classList.remove('hidden');
    });
    
    deleteDraftButton?.addEventListener('focusin', () => {
        deleteWarning.classList.remove('hidden');
    });
    
    // Show confirmation modal when Delete Permanently is clicked
    deleteDraftButton?.addEventListener('click', () => {
        clearDraftModal.classList.add('hidden');
        deleteConfirmModal.classList.remove('hidden');
    });
    
    // Hide confirmation modal when Cancel is clicked
    cancelDeleteButton?.addEventListener('click', () => {
        deleteConfirmModal.classList.add('hidden');
        clearDraftModal.classList.remove('hidden');
    });
    
    // Hide confirmation modal when clicking outside
    deleteConfirmModal?.addEventListener('click', (e) => {
        if (e.target === deleteConfirmModal) {
            deleteConfirmModal.classList.add('hidden');
            clearDraftModal.classList.remove('hidden');
        }
    });
    
    // Save Draft button - just close modal (draft is already in session)
    saveDraftButton?.addEventListener('click', () => {
        clearDraftModal.classList.add('hidden');
        deleteWarning.classList.add('hidden');
        // Show a brief confirmation message
        const originalText = saveDraftButton.textContent;
        saveDraftButton.textContent = '✓ Draft Saved';
        saveDraftButton.classList.remove('bg-blue-600', 'hover:bg-blue-500');
        saveDraftButton.classList.add('bg-green-600');
        setTimeout(() => {
            saveDraftButton.textContent = originalText;
            saveDraftButton.classList.remove('bg-green-600');
            saveDraftButton.classList.add('bg-blue-600', 'hover:bg-blue-500');
        }, 2000);
    });
    
    // Handle delete confirmation - use fetch API
    confirmDeleteButton?.addEventListener('click', async () => {
        if (!confirmDeleteButton) return;
        
        // Disable button during request
        confirmDeleteButton.disabled = true;
        const originalText = confirmDeleteButton.textContent;
        confirmDeleteButton.textContent = 'Deleting...';
        
        try {
            const formData = new FormData();
            formData.append('action', 'delete');
            
            const response = await fetch('/clear-draft', {
                method: 'POST',
                body: formData,
                redirect: 'follow'
            });
            
            if (response.ok || response.status === 200 || response.redirected) {
                // Success - redirect to create-event page
                window.location.href = '/create-event';
            } else if (response.status === 404) {
                // Not found error
                alert('Route not found. Please refresh the page and try again.');
                confirmDeleteButton.disabled = false;
                confirmDeleteButton.textContent = originalText;
            } else {
                // Handle other errors
                const errorText = await response.text();
                console.error('Delete failed:', response.status, errorText);
                alert('Failed to delete draft. Please try again.');
                confirmDeleteButton.disabled = false;
                confirmDeleteButton.textContent = originalText;
            }
        } catch (error) {
            console.error('Error deleting draft:', error);
            alert('An error occurred while deleting the draft. Please try again.');
            confirmDeleteButton.disabled = false;
            confirmDeleteButton.textContent = originalText;
        }
    });
</script>
{% endblock %}